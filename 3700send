#!/usr/bin/python3

import sys
import socket
import time
import datetime
import select
import json

MSG_SIZE = 1500
DATA_SIZE = 1000
HEADER_SIZE = 8
TIMEOUT = 30
SEQ = 1
ACK = 0
WIN_SIZE = 0
seq_nums = []

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

def make_packet(data):
    global SEQ
    pckt = SEQ.to_bytes(2, "little")
#    pckt += ACK.to_bytes(2, "little")
#    pckt_len = len(data)
#    pckt_len_flags = pckt_len << 4 | flags
 #   pckt += pckt_len.to_bytes(2, "little")
#    pckt += WIN_SIZE.to_bytes(2, "little")
#a word plus the data, 1472 - 32 = 1440 bytes of data 
    pckt += data.encode("ascii")
    return pckt

def send_next_packet():
    global SEQ
    print("WE ARE IN SEND NEXT PACKET") 

    data = sys.stdin.read() #todo: read all data instead of just 1000
    focusData = data
    if (len(data) > 0):

        while len(focusData) > 1440:
            packet_data = 0 
            for byte in range(0, 1440): 
                packet_data = packet_data + focusData[byte] 
                msg = make_packet(packet_data) 
                print("SENDING", msg) 
                SEQ += 1
                seq_nums.append(SEQ) 
                sock.sendto(msg, dest)
                focusData = data[1440:]  

        if len(focusData) > 0: 
            msg = make_packet(focusData) 
            print("SENDING", msg) 
            SEQ += 1
            seq_nums.append(SEQ)
            sock.sendto(msg, dest) 
    
        '''
        if sock.sendto(msg, dest) < len(msg):
            log("[error] unable to fully send packet")
        else:
            log("[send data] " + str(SEQ) + " (" + str(len(data)) + ")")
        '''
        return True
    else:
        return False

#todo: do the syn/ack thing

# Send first packet
send_next_packet()

# Now read in data, send packets
while True:
    log("ABOUT TO SLEEP")
    result = sock.recvfrom(MSG_SIZE)

    if result:
        (data, addr) = result
        decoded = int.from_bytes(data, "little")

        # If there is an ack, send next packet
        if decoded in seq_nums: 
            seq_nums.remove(decoded) 
            log("[recv ack] " + str(decoded))

        #3 second wait 

        # Try to send next packet; break if no more data
        #if (not send_next_packet()):
        break 
    else:
        log("[error] timeout")
        sys.exit(-1)

SEQ = 0
final_msg = SEQ.to_bytes(2, "little") 
print("FINAL MSG IS", final_msg) 
sock.sendto(final_msg, dest)
sys.exit(0)
