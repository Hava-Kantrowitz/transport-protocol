#!/usr/bin/python3

import sys
import socket
import time
import datetime
import select
import math

DATA_SIZE = 100
TIMEOUT = 30
TIMEOUT_ACKS = 3
SEQ = 0
seq_nums = {}
num_retrans = 0

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT_ACKS)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

def make_packet(data, num_pckts):
    global SEQ
    pckt = SEQ.to_bytes(2, "little")
    pckt += num_pckts.to_bytes(2, "little")
#    pckt += ACK.to_bytes(2, "little")
#    pckt_len = len(data)
#    pckt_len_flags = pckt_len << 4 | flags
 #   pckt += pckt_len.to_bytes(2, "little")
#    pckt += WIN_SIZE.to_bytes(2, "little")
#a word plus the data, 1472 - 32 = 1440 bytes of data 
    pckt += data.encode("ascii")
    return pckt

def send_packets():
    global SEQ
    #print("WE ARE IN SEND NEXT PACKET") 

    data = sys.stdin.read() #todo: read all data instead of just 1000
    num_pckts = math.ceil(len(data) / DATA_SIZE)
    focusData = data
    if (len(data) > 0):

        while len(focusData) > DATA_SIZE:
            packet_data = ""
            for byte in range(0, DATA_SIZE): 
                packet_data = packet_data + focusData[byte] 
                
            msg = make_packet(packet_data, num_pckts) 
            seq_nums[SEQ] = msg
            log("[sending] " + str(SEQ))
            sock.sendto(msg, dest)
            SEQ += 1
            focusData = data[DATA_SIZE:]
            data = focusData

        if len(focusData) > 0: 
            msg = make_packet(focusData, num_pckts) 
            seq_nums[SEQ] = msg
            log("[sending] " + str(SEQ))
            sock.sendto(msg, dest) 
            SEQ += 1
    
        return True
    else:
        return False


send_packets()

# Now read in data, send packets
while True:
    log("ABOUT TO SLEEP")
    try:
        result = sock.recvfrom(DATA_SIZE)

        if result:
            (data, addr) = result
            decoded = int.from_bytes(data, "little")

            #remove acked packet from dict
            if decoded in seq_nums.keys(): 
                del seq_nums[decoded] 
                log("[recv ack] " + str(decoded))

            #if all acks received, break out
            if len(seq_nums.keys()) == 0:
                break
        else:
            log("[error] timeout")
            sys.exit(-1)

    except OSError:
        num_retrans += 1
        if num_retrans >= 7:
            log("retransmits exceeded, all data might have been received - exiting")
            sys.exit(0)
 
        for seq_num in seq_nums.keys():
            log("[retransmit] " + str(seq_num))
            sock.sendto(seq_nums[seq_num], dest)

#SEQ = 0
#final_msg = SEQ.to_bytes(2, "little") 
#log("SEND END") 
#sock.sendto(final_msg, dest)
sys.exit(0)
